<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>使用栈实现一个简单的计算器 | Rylaris的个人技术博客</title><meta name="description" content="使用栈实现一个简单的计算器"><meta name="keywords" content="数据结构,Java"><meta name="author" content="Rylaris"><meta name="copyright" content="Rylaris"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="canonical" href="http://yoursite.com/2019/09/28/如何使用 Stack 数据结构粗暴的实现一个简单的 Calculator/"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:title" content="使用栈实现一个简单的计算器"><meta name="twitter:description" content="使用栈实现一个简单的计算器"><meta name="twitter:image" content="https://i.loli.net/2019/09/28/KcUoiwE4YdR2y93.png"><meta property="og:type" content="article"><meta property="og:title" content="使用栈实现一个简单的计算器"><meta property="og:url" content="http://yoursite.com/2019/09/28/如何使用 Stack 数据结构粗暴的实现一个简单的 Calculator/"><meta property="og:site_name" content="Rylaris的个人技术博客"><meta property="og:description" content="使用栈实现一个简单的计算器"><meta property="og:image" content="https://i.loli.net/2019/09/28/KcUoiwE4YdR2y93.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="prev" title="汉诺塔问题的递归算法" href="http://yoursite.com/2019/10/17/汉诺塔问题的递归算法/"><link rel="next" title="基于 GitHub Pages 使用 Hexo 在 macOS 环境下搭建个人博客" href="http://yoursite.com/2019/09/07/基于 GitHub Pages 使用 Hexo 在 macOS 环境下搭建个人博客/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://rylaris.github.io/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  highlight_copy: 'true',
  highlight_lang: 'true',
  highlight_shrink: 'false',
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: '添加书签',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  copyright: undefined,
  copy_copyright_js: false
  
}</script></head><body><div id="header"> <div id="page-header"><span class="pull-left" id="blog_name"><a class="blog_title" id="site-name" href="/">Rylaris的个人技术博客</a></span><i class="fa fa-bars fa-fw toggle-menu pull-right close" aria-hidden="true"></i><span class="pull-right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fa fa-picture-o"></i><span> 相册</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 清单</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/book/"><i class="fa-fw fa fa-book"></i><span> 书单</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 影单</span></a></li></ul></div><script>document.body.addEventListener('touchstart', function(){ });</script></div></span><span class="pull-right" id="search_button"></span></div></div><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="lozad avatar_img" src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'"></div><div class="mobile_post_data"><div class="mobile_data_item is_center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">18</div></a></div></div><div class="mobile_data_item is_center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">13</div></a></div></div><div class="mobile_data_item is_center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">3</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fa fa-picture-o"></i><span> 相册</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 清单</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/book/"><i class="fa-fw fa fa-book"></i><span> 书单</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 影单</span></a></li></ul></div><script>document.body.addEventListener('touchstart', function(){ });</script></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">目录</div><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#使用栈实现一个简单的计算器"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">使用栈实现一个简单的计算器</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#目标"><span class="toc_mobile_items-number">1.1.</span> <span class="toc_mobile_items-text">目标</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#基本原理"><span class="toc_mobile_items-number">1.2.</span> <span class="toc_mobile_items-text">基本原理</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#关于-Stack"><span class="toc_mobile_items-number">1.2.1.</span> <span class="toc_mobile_items-text">关于 Stack</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#关于-Calculator"><span class="toc_mobile_items-number">1.2.2.</span> <span class="toc_mobile_items-text">关于 Calculator</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#实现思路"><span class="toc_mobile_items-number">1.3.</span> <span class="toc_mobile_items-text">实现思路</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#遇到的困难"><span class="toc_mobile_items-number">1.4.</span> <span class="toc_mobile_items-text">遇到的困难</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#如何终止运算"><span class="toc_mobile_items-number">1.4.1.</span> <span class="toc_mobile_items-text">如何终止运算</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#如何识别并处理非法表达式"><span class="toc_mobile_items-number">1.4.2.</span> <span class="toc_mobile_items-text">如何识别并处理非法表达式</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#如何将输入的表达式字符串处理为浮点型数据"><span class="toc_mobile_items-number">1.4.3.</span> <span class="toc_mobile_items-text">如何将输入的表达式字符串处理为浮点型数据</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#如何判断操作符的优先级"><span class="toc_mobile_items-number">1.4.4.</span> <span class="toc_mobile_items-text">如何判断操作符的优先级</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#存在的问题"><span class="toc_mobile_items-number">1.5.</span> <span class="toc_mobile_items-text">存在的问题</span></a></li></ol></li></ol></div></div><div id="body-wrap"><div id="web_bg"></div><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#使用栈实现一个简单的计算器"><span class="toc-number">1.</span> <span class="toc-text">使用栈实现一个简单的计算器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#目标"><span class="toc-number">1.1.</span> <span class="toc-text">目标</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#基本原理"><span class="toc-number">1.2.</span> <span class="toc-text">基本原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#关于-Stack"><span class="toc-number">1.2.1.</span> <span class="toc-text">关于 Stack</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#关于-Calculator"><span class="toc-number">1.2.2.</span> <span class="toc-text">关于 Calculator</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#实现思路"><span class="toc-number">1.3.</span> <span class="toc-text">实现思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#遇到的困难"><span class="toc-number">1.4.</span> <span class="toc-text">遇到的困难</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#如何终止运算"><span class="toc-number">1.4.1.</span> <span class="toc-text">如何终止运算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何识别并处理非法表达式"><span class="toc-number">1.4.2.</span> <span class="toc-text">如何识别并处理非法表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何将输入的表达式字符串处理为浮点型数据"><span class="toc-number">1.4.3.</span> <span class="toc-text">如何将输入的表达式字符串处理为浮点型数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何判断操作符的优先级"><span class="toc-number">1.4.4.</span> <span class="toc-text">如何判断操作符的优先级</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#存在的问题"><span class="toc-number">1.5.</span> <span class="toc-text">存在的问题</span></a></li></ol></li></ol></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://i.loli.net/2019/09/28/KcUoiwE4YdR2y93.png)"><div id="post-info"><div id="post-title"><div class="posttitle">使用栈实现一个简单的计算器</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2019-09-28<span class="post-meta__separator">|</span><i class="fa fa-history" aria-hidden="true"></i> 更新于 2019-09-28</time><span class="post-meta__separator mobile_hidden">|</span><span class="mobile_hidden"><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/学习笔记/">学习笔记</a></span><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">4.6k</span><span class="post-meta__separator">|</span><span>阅读时长: 14 分钟</span><span class="post-meta__separator">|</span><span>阅读量: </span><span id="busuanzi_value_page_pv"></span></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><h1 id="使用栈实现一个简单的计算器"><a href="#使用栈实现一个简单的计算器" class="headerlink" title="使用栈实现一个简单的计算器"></a>使用栈实现一个简单的计算器</h1><hr>
<h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>向计算机输入完整的四则运算表达式，计算机输出计算结果，并且在此基础上适当的加强程序的健壮性，让程序具有识别非法表达式以及一定程度上整理表达式的能力，例如：</p>
<p>输入： <code>(56-23)/8-4</code> ，输出： <code>0.125</code></p>
<p>输入： <code>34+p(u89-12.3)k/3</code> ，输出： <code>59.566667</code></p>
<p>输入： <code>(8*(7-4)</code> ，输出： <code>输入有误</code></p>
<hr>
<h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><h3 id="关于-Stack"><a href="#关于-Stack" class="headerlink" title="关于 Stack"></a>关于 <code>Stack</code></h3><p><code>Stack  是数据结构中最基础最简单的一种（也是我才学会的两种之一），它的特点是 First In Last Out ，先进后出，就像放在架子上的盘子，想要取出下面的盘子，必须拿出上面的盘子。对于一个</code>Stack` ，我们有三个基本操作：</p>
<ul>
<li><code>push</code> ：将元素压入栈顶，可以类比为将盘子放到架子上。</li>
<li><code>pop</code> ：将栈顶元素弹出，可以类比为取下架子上的第一个盘子。</li>
<li><code>top</code> ：返回栈顶元素。</li>
</ul>
<p>在计算机中， <code>Stack</code> 有两种最主要的实现方法， <code>LinkedStack</code> 和 <code>ArrayStack</code> ，前者基于单链表存储，后者基于数组存储。基于数组存储的 <code>Stack</code> 较为方便理解，所有元素存储在数组中，数组存储的最后一个元素即为 <code>Stack</code> 的栈顶元素，压入新元素时自然而然存储在数组中前一个栈顶元素下标+1的位置。基于单链表存储的 <code>Stack</code> 相对来说更难理解。</p>
<p>简单介绍一下单链表的原理，所有元素分别存储在各自的节点中，这个节点同时还存储了另一个节点的地址。这样的话，当获取了一个节点，在获取了所存储的元素的值的同时，还获得了另一个节点的地址，而获得了另一个节点的地址，就相当于获得了另一个节点所存储的元素的值以及另一个节点存储的又一个节点的地址。如此循环往复，每个节点存储下一个节点的地址，找到一个节点就能依次找到所有之后的节点，所有节点像一根线一样穿在一起，所以称为单链表。</p>
<p>知道了单链表的原理以后，回到 <code>Stack</code> 的实现，我们只需要构造一个节点，专门用于存储栈顶元素所在的节点地址，将这个节点称为 <code>topNode</code> ，每压入一个新的元素，便构造一个新的节点，存储新元素以及 <code>topNode</code> 所存储的原栈顶元素所在的节点地址，再修改 <code>topNode</code> 使其存储新的栈顶元素的节点地址。当要弹出栈顶元素时，修改 <code>topNode</code> 令其指向栈顶元素的下一个元素所在节点的地址（该地址通过栈顶元素获得），使该地址所在节点的元素成为新的栈顶元素，与此同时原先栈顶元素由于再没有指向它的变量，在某些语言中就会被系统当作垃圾自动回收内存。</p>
<p>两种 <code>Stack</code> 在实际应用中也稍有区别， <code>ArrayStack</code> 的大小取决于数组的大小，调整复杂，且在声明初始就已经分配了内存，不灵活，但是可以通过数组下标迅速访问某一个元素。 <code>LinkedStack</code> 的大小不固定，可以调整，在插入数据项时动态的分配内存，自由度大，但是若要访问某一个元素必须从栈顶元素开始遍历。</p>
<h3 id="关于-Calculator"><a href="#关于-Calculator" class="headerlink" title="关于 Calculator"></a>关于 Calculator</h3><p> Calculator 的基本原理是将中缀表达式转换为后缀表达式进行求解。例如， <code>1+2*(4-3)</code> 这样一个符合我们阅读习惯的表达式就是中缀表达式，而将该表达式转换为后缀表达式即为： <code>1243-*+</code>  ，在计算机系统中，从左到右读取后缀表达式，当遇到操作符时，取出操作符和操作符前的两个操作数，计算后将得到的结果放回原位，继续读取。以上面的表达式为例，读取到 <code>-</code> 号的时候，取出 <code>43-</code> ，计算 <code>4-3</code> ，得到 <code>1</code> 放回原位，表达式变为 <code>121*+</code> ，读取到 <code>*</code> 号的时候，取出 <code>21*</code> ，计算 <code>2*1</code> ，得到 <code>2</code> 放回原位，表达式变为 <code>12+</code> ，读取到 <code>+</code> 号的时候，取出 <code>12+</code> ，计算 <code>1+2</code> ，得到 <code>3</code> 放回原位，此时只剩下 <code>3</code> ，即为表达式的结果。</p>
<p>简单的介绍了计算后缀表达式的原理，下一步需要将中缀表达式转换为后缀表达式，这里有一套方法直接给出：</p>
<p>创建两个Stack，分别存储操作符和操作数，从左到右扫描中缀表达式，若为操作数直接压入操作数栈，若为操作符，则与操作符栈顶元素进行优先级的比较，</p>
<p>若大于，则压入操作符栈继续扫描；</p>
<p>若等于，退出栈顶元素继续扫描（只有一种情况会等于，两个操作符分别是(，)，这时候操作符优先级相等）；</p>
<p>若小于，从操作符栈退出栈顶元素，并从操作数栈退出两个元素，进行计算后压入操作数栈，并继续用读取到的操作符与操作符栈中的下一个操作符进行比较。这套方法结束后，操作数栈中的元素即为表达式的结果。</p>
<hr>
<h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><p>由于相对来说，我更熟悉 <code>Java</code> 语言，所以我选择使用 <code>Java</code> 语言来实现 Calculator ，在 <code>Stack</code> 的选择上，由于给定的表达式长度唯一，使用 <code>ArrayStack</code> 也无需担心无法灵活调整大小的困难，故而 <code>ArrayStack</code> 和 <code>LinkedStack</code> 在这个实例中效果几乎是等效的，选取自己熟悉的 <code>Stack</code> 类型即可。我在这里选择的是 <code>LinkedStack</code> 。</p>
<p>我们需要创建两个类，一个 <code>Stack</code> 类实现创建 <code>Stack</code> 以及 <code>Stack</code> 的基本操作，一个 Calculator 类负责对输入的字符串进行计算。</p>
<p>将表达式输入到程序中以后，首先第一步先格式化表达式，整理表达式使其不含非法字符，格式化表达式以后对表达式进行判别，如果表达式非法，直接返回不再进行后续操作，如果表达式合法，开始从左到右扫描表达式，按照之前介绍的方法将中缀表达式转换为后缀表达式并进行求值，最后返回计算结果。</p>
<hr>
<h2 id="遇到的困难"><a href="#遇到的困难" class="headerlink" title="遇到的困难"></a>遇到的困难</h2><h3 id="如何终止运算"><a href="#如何终止运算" class="headerlink" title="如何终止运算"></a>如何终止运算</h3><p>为了美观以及符合日常习惯，我们需要在表达式的末尾加上一个 <code>=</code> 号，当扫描到这个 <code>=</code> 号的时候，即终止运算。但是之前给出的计算中缀表达式的方法并不包括如何处理终止符的方法，在这里我们改进那个方法，使其能够处理终止符。</p>
<p>我们在开始操作前先向操作符栈压入一个 <code>=</code> 号，当扫描到倒数第二个操作符时，此时理论上计算完后操作数栈的顶部已经是计算式结果了，并且操作符栈的除之前压入的 <code>=</code> 号外再无第二个操作符，此时再向下扫描得到末尾的 <code>=</code> 号，继续进行与操作符栈栈顶进行比较的操作，两者都是 <code>=</code> 号，即判断为运算结束，此时返回操作数栈栈顶作为结果输出到控制台。</p>
<h3 id="如何识别并处理非法表达式"><a href="#如何识别并处理非法表达式" class="headerlink" title="如何识别并处理非法表达式"></a>如何识别并处理非法表达式</h3><p>首先我们观察几个典型的非法表达式，</p>
<p><code>34+p(u89-12.3)k/3</code> ， <code>89.5*749*+25)</code> ， <code>(8*(7-4)</code> ， <code>65*(72+98)(70-45)</code> ， <code>6*</code> ， <code>)5+3(</code> ， <code>3+(2..5*4)/2.</code></p>
<p>不难看出非法表达式的几个错误：</p>
<ol>
<li>含有非法字符</li>
<li>括号数量或顺序不匹配</li>
<li>小数点数量异常</li>
<li>缺少操作符或操作数</li>
</ol>
<p>这些错误又可以分为两类，可以还原成合法表达式的错误以及不可以还原的错误，分析完非法表达式的问题，我们要做的就是将我们可以处理的非法表达式还原成合法表达式，不能处理的返回输入异常。例如 <code>6*</code> 我们便无法还原，我们无法揣测用户在乘号后面还想要输入的内容。 <code>34+p(u89-12.3)k/3</code> 我们就可以还原，只要把非法字符删除就可以得到一个合法表达式。</p>
<p>含有非法字符以及小数点数量异常是我们能处理的两类错误，归结起来这两类错误本质都是用户在已经输入了合法表达式的基础上多输入了额外的字符。处理非法字符较为简单，从左到右扫描表达式，遇到不是操作符或者操作数的字符就将其从字符串中删除，这里我使用了 <code>Java</code> 中 <code>String</code> 类的 <code>substring</code> 方法将表达式以非法字符为分界拆分为两个子串，再将子串拼接到一起，实现删除非法字符的功能。这里用到两个函数， <code>isNum</code> 和 <code>isOperator</code> ，判断给定的字符是否属于操作数以及操作符，具体实现是十分简单的 <code>boolean</code> 函数，不再赘述。</p>
<p>而小数点数量异常分为两类，一类是在浮点数中输入了过多的小数点，例如2..5，另一类是在整形数的结尾误输入了小数点，例如2.这样的，我们可以通过它们的规律来对这类错误进行处理，第一类的特点是在扫描到一个小数点后下一个扫描到的字符还是小数点，第二类的特点是在扫描到一个小数点后下一个扫描到的字符不是数字字符而是操作符字符。</p>
<p>所以非法字符错误和小数点错误最终处理方法都是删除特定的字符，只是判断条件不同，下面给出关键代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arithmetic.length(); i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!isNum(arithmetic.charAt(i)) &amp;&amp; !isOperator(arithmetic.charAt(i)))&#123;</span><br><span class="line">        str = arithmetic.substring(<span class="number">0</span>,i) + arithmetic.substring(i + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(arithmetic.charAt(i) == <span class="string">'.'</span> &amp;&amp; arithmetic.charAt(i + <span class="number">1</span>) == <span class="string">'.'</span>)&#123;</span><br><span class="line">        str = arithmetic.substring(<span class="number">0</span>,i) + arithmetic.substring(i + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(arithmetic.charAt(i) == <span class="string">'.'</span> &amp;&amp; isOperator(arithmetic.charAt(i + <span class="number">1</span>)))&#123;</span><br><span class="line">        str = arithmetic.substring(<span class="number">0</span>,i) + arithmetic.substring(i + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解决了能处理的错误，剩下不能处理的错误我们需要找出其通性进行判断，主要有三个判断的条件：</p>
<p>第一：括号数量不匹配，例如 <code>(8*(7-4)</code> ，只需要写一个函数，扫描表达式分别统计左右括号数目即可。</p>
<p>第二：括号顺序不匹配，例如 <code>)5+3(</code> ，要判断这个条件需要扫描表达式，并记下左右括号每次出现的位置，最后比较是否有第n个右括号在第n个左括号之前的情况，在一个合法的表达式中，第n个左括号总是位于第n个右括号之前，可与第一个判断条件合并到一个函数中进行判断。</p>
<p>第三：运算符数是否是运算数数-1，在合法表达式中，这条关系总是成立，通过这个条件的判断，可以把缺省操作符或者操作数的非法表达式检测出来。这个判断很简单，只需要遍历表达式统计数目即可。</p>
<p>判断括号匹配的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isBracketsPair</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] leftBracketPosition = <span class="keyword">new</span> <span class="keyword">int</span>[arithmetic.length()],</span><br><span class="line">            rightBracketPosition = <span class="keyword">new</span> <span class="keyword">int</span>[arithmetic.length()];</span><br><span class="line">    <span class="keyword">int</span> numOfLeftBrackets = <span class="number">0</span>, numOfRightBrackets = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arithmetic.length(); i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arithmetic.charAt(i) == <span class="string">'('</span>)&#123;</span><br><span class="line">            leftBracketPosition[numOfLeftBrackets] = i;</span><br><span class="line">            numOfLeftBrackets++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(arithmetic.charAt(i) == <span class="string">')'</span>)&#123;</span><br><span class="line">            rightBracketPosition[numOfRightBrackets] = i;</span><br><span class="line">            numOfRightBrackets++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arithmetic.length(); i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (leftBracketPosition[i] &gt; rightBracketPosition[i])</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> numOfLeftBrackets == numOfRightBrackets;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此非法表达式的识别与处理就结束了，通过这几个方法，可以处理绝大部分的非法表达式，如果有不能处理的，请务必告诉我，方便继续改进。</p>
<h3 id="如何将输入的表达式字符串处理为浮点型数据"><a href="#如何将输入的表达式字符串处理为浮点型数据" class="headerlink" title="如何将输入的表达式字符串处理为浮点型数据"></a>如何将输入的表达式字符串处理为浮点型数据</h3><p>我们在输入表达式的时候将表达式存储在了一个 <code>String</code> 类型的变量中，这也就意味着，操作符以字符的形式存储了，操作数也以字符的形式存储了，存储的其实是它们的 <code>ASCII</code> 码值，而不是字面值。以0为例，0对应的字符的 <code>ASCII</code> 码值为48，所以当我们从表达式中读取数字的时候，读取到的其实是它们的 <code>ASCII</code> 码，如果不进行处理，我们不可能用 <code>ASCII</code> 码进行计算，所以这里涉及到一个问题就是如何将以 <code>ASCII</code> 码值形式存储的数字字符转换浮点型的字面值。</p>
<p>还有第二个问题，如果每个数都是10以内的整数，很方便就能进行转换，但是实际上这是不存在的情况，计算式中会有大数，也会有浮点数。以12.5为例，它存储在 <code>String</code> 中并不是一个值，而是四个值，分别是1，2，小数点，5对应的 <code>ASCII</code> 码，所以第二个问题就是如何连续读取n个组成一个数字的字符并将它们转换为浮点数。</p>
<p>解决了第二个问题，也就解决了第一个问题，我们将第二个问题分为两个小问题来进行解决。首先解决将操作数对应的 <code>ASCII</code> 码值转换为字面值的问题，我们只需要将 <code>ASCII</code> 码的数减去48即为字面值。这个问题十分简单，但解决了这个问题后，我们的问题就变成了如何将n个顺序排列的浮点数以个十百千万的位数顺序组合成一个新的浮点数。</p>
<p>接下来给出完整解决思路，我们从左到右扫描表达式，当扫描到代表数字的字符时，将该字符转换为浮点型字面值并赋给中间变量，然后继续读取下一位，如果下一位还是数字，先转换成浮点型字面值，然后将中间变量扩大10倍，加上新一位的字面值，以此类推。</p>
<p>以123为例，首先扫描到1，对应的 <code>ASCII</code> 码为49，转换为字面值1，赋给中间变量，此时中间变量值为1；然后扫描到2，转换为字面值后，先将中间变量扩大10倍变成10，再加上2变成12；然后扫描到3，中间变量扩大10倍，加上3变成123，得到三个字符所代表的字面值。</p>
<p>但是形同123这样的数只是最基本的整数，以整数为例介绍算法较为简单，针对带小数部分的浮点数，还需要修改我们的步骤。我想到的是利用浮点数只是小数位数不同的特点，先忽略小数点，将浮点数的整数部分和小数部分一起组合为一个数，再根据小数点后有几位数对组合成的数进行倍数的放缩，这样便可以达到读取带有小数部分的浮点数的目的。</p>
<p>以123.45为例，前三位正常扫描，扫描到小数点的时候，进行标记，这个标记的含义代表了是否读取到小数点。然后继续读取后面的浮点数，每读取到一位浮点数，并且检测到已经读取到小数点的标记，则将放缩系数扩大10倍，最后当完全读取完毕，我们获得了一个浮点数12345，一个放缩系数100，两者相除得到123.45，成功获取到这五个字符所代表的字面值。</p>
<p>下面给出具体实现代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> countDecimalPlaces = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">boolean</span> passDecimalPoint = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">double</span> temp = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(isNum(arithmetic.charAt(i)))&#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(passDecimalPoint)</span><br><span class="line">            countDecimalPlaces *= <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">if</span>(arithmetic.charAt(i) == <span class="string">'.'</span>) &#123;</span><br><span class="line">            passDecimalPoint = <span class="keyword">true</span>;</span><br><span class="line">            i++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        temp = temp * <span class="number">10</span> + ASCIINumToInt(arithmetic.charAt(i));</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(isNum(arithmetic.charAt(i)));</span><br><span class="line">    temp /= countDecimalPlaces;</span><br><span class="line">    countDecimalPlaces = <span class="number">1</span>;</span><br><span class="line">    passDecimalPoint = <span class="keyword">false</span>;</span><br><span class="line">  	temp = <span class="number">0</span>;</span><br><span class="line">    i--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="如何判断操作符的优先级"><a href="#如何判断操作符的优先级" class="headerlink" title="如何判断操作符的优先级"></a>如何判断操作符的优先级</h3><p>在将中缀表达式转换为后缀表达式求值的过程中我们需要判断操作符的优先级然后根据判断结果进行不同的操作，我的方法是使用一个二维数组存储操作符的优先级：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] operatorRelationship = &#123;&#123;<span class="string">'+'</span>,<span class="number">3</span>,<span class="number">2</span>&#125;,</span><br><span class="line">                                &#123;<span class="string">'-'</span>,<span class="number">3</span>,<span class="number">2</span>&#125;,</span><br><span class="line">                                &#123;<span class="string">'*'</span>,<span class="number">5</span>,<span class="number">4</span>&#125;,</span><br><span class="line">                                &#123;<span class="string">'/'</span>,<span class="number">5</span>,<span class="number">4</span>&#125;,</span><br><span class="line">                                &#123;<span class="string">'('</span>,<span class="number">1</span>,<span class="number">6</span>&#125;,</span><br><span class="line">                                &#123;<span class="string">')'</span>,<span class="number">6</span>,<span class="number">1</span>&#125;,</span><br><span class="line">                                &#123;<span class="string">'='</span>,<span class="number">0</span>,<span class="number">0</span>&#125;&#125;;</span><br></pre></td></tr></table></figure>

<p>介绍一下二维数组的含义，二维数组的第一列存储了操作符，第二列存储了操作符的栈内优先级，第三列存储了操作符的扫描优先级。简单解释一下栈内优先级和扫描优先级，扫描到的新操作符与栈顶操作符进行优先级对比时，扫描到的新操作符使用扫描优先级去对比栈顶操作符的栈内优先级，例如假设当前操作符栈内元素为 <code>+</code> ，扫描到下一个操作符为 <code>-</code> ，使用 <code>-</code> 的扫描优先级3去对比 <code>+</code> 的栈内优先级2，得到大于的结果，所以将 <code>-</code> 号压入操作符栈继续扫描。只需要遍历二维数组的第一列，发现匹配的操作符时，返回指定的优先级即可进行对比。需要注意的是在遍历二维数组之前必须将表达式格式化保证没有非法字符，否则可能会引起空指针异常。</p>
<hr>
<h2 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h2><p>之所以说这是一个粗暴的实现是有原因的，如果使用 <code>Java</code> 和 <code>C++</code> 的标准 <code>Stack</code> 类，可以指定 <code>Stack</code> 所存储的类型，分别对操作符和操作数使用不同类型的 <code>Stack</code> 进行存储，就避免了将字符串转换为浮点型字面值的问题。这个问题主要还是源自于自身技术的欠缺，将来修改了 <code>Stack</code> 类的实现后再对这个问题进行弥补。</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Rylaris</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://yoursite.com/2019/09/28/如何使用 Stack 数据结构粗暴的实现一个简单的 Calculator/">http://yoursite.com/2019/09/28/如何使用 Stack 数据结构粗暴的实现一个简单的 Calculator/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://yoursite.com">Rylaris的个人技术博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/数据结构/">数据结构    </a><a class="post-meta__tags" href="/tags/Java/">Java    </a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2019/09/28/KcUoiwE4YdR2y93.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button"><i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lozad post-qr-code__img" src="/img/wechat.JPG"><div class="post-qr-code__desc">WeChat Pay</div></li><li class="reward-item"><img class="lozad post-qr-code__img" src="/img/alipay.JPG"><div class="post-qr-code__desc">Alipay</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull-left"><a href="/2019/10/17/汉诺塔问题的递归算法/"><img class="prev_cover lozad" data-src="https://i.loli.net/2019/09/28/KcUoiwE4YdR2y93.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">上一篇</div><div class="prev_info"><span>汉诺塔问题的递归算法</span></div></a></div><div class="next-post pull-right"><a href="/2019/09/07/基于 GitHub Pages 使用 Hexo 在 macOS 环境下搭建个人博客/"><img class="next_cover lozad" data-src="https://i.loli.net/2019/09/07/il8AR46dMzTEsJ3.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="label">下一篇</div><div class="next_info"><span>基于 GitHub Pages 使用 Hexo 在 macOS 环境下搭建个人博客</span></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2019/11/03/二叉树的非递归遍历/" title="二叉树的非递归遍历"><img class="relatedPosts_cover lozad" data-src="https://i.loli.net/2019/09/28/KcUoiwE4YdR2y93.png"><div class="relatedPosts_title">二叉树的非递归遍历</div></a></div><div class="relatedPosts_item"><a href="/2019/10/25/利用循环链表解决约瑟夫问题/" title="利用循环链表解决约瑟夫问题"><img class="relatedPosts_cover lozad" data-src="https://i.loli.net/2019/09/28/KcUoiwE4YdR2y93.png"><div class="relatedPosts_title">利用循环链表解决约瑟夫问题</div></a></div></div><div class="clear_both"></div></div></div></div><footer style="background-image: url(https://i.loli.net/2019/09/28/KcUoiwE4YdR2y93.png)"><div id="footer"><div class="copyright">&copy;2019 By Rylaris</div><div class="framework-info"><span>驱动 </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly"><span>Butterfly</span></a></div><div class="footer_custom_text">科学技术是第一生产力。</div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换">简</a><i class="nightshift fa fa-moon-o" id="nightshift" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/js-cookie@2/src/js.cookie.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/nightshift.js"></script><script src="/js/baidupush.js"> </script><script src="/js/tw_cn.js"></script><script>translateInitilization()

</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@1.2.2/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script><script>const observer = lozad(); // lazy loads elements with default selector as '.lozad'
observer.observe();
</script></body></html>